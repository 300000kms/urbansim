


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>urbansim.sim.simulation &mdash; urbansim 0.2dev documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="urbansim 0.2dev documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../index.html" class="fa fa-home"> urbansim</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../gettingstarted.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../gettingstarted.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gettingstarted.html#tools-of-the-trade">Tools of the Trade</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gettingstarted.html#a-gentle-introduction-to-urbansim">A Gentle Introduction to UrbanSim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gettingstarted.html#specifying-scenario-inputs">Specifying Scenario Inputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gettingstarted.html#taking-the-next-step">Taking the Next Step</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#basic-example-residential-price-hedonic">Basic Example - Residential Price Hedonic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#complete-example-san-francisco-urbansim-modules">Complete Example - San Francisco UrbanSim Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#complete-example-san-francisco-urbansim-workflows">Complete Example - San Francisco UrbanSim Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples.html#model-implementation-choices">Model Implementation Choices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../sim/index.html">Simulation Framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../sim/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../sim/index.html#tables">Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../sim/index.html#columns">Columns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../sim/index.html#injectables">Injectables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../sim/index.html#models">Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../sim/index.html#running-simulations">Running Simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../sim/index.html#api">API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../models/index.html">Core Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../models/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../models/index.html#contents">Contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Real Estate Development Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/index.html#module-urbansim.developer.sqftproforma">Square Foot Pro Forma API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/index.html#module-urbansim.developer.developer">Developer Model API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils/index.html">UrbanSim Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#about">About</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../utils/index.html#contents">Contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../maps/index.html">DataFrame Explorer</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#website-description">Website Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#what-s-it-doing-exactly">What&#8217;s it Doing Exactly?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../maps/index.html#module-urbansim.maps.dframe_explorer">DataFrame Explorer API</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">urbansim</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>urbansim.sim.simulation</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <h1>Source code for urbansim.sim.simulation</h1><pre>
from __future__ import print_function

import inspect
import logging
import warnings
from collections import Callable, namedtuple

import pandas as pd
import tables
import toolz
import time

from ..utils.misc import column_map
from ..utils.logutil import log_start_finish

warnings.filterwarnings('ignore', category=tables.NaturalNameWarning)
logger = logging.getLogger(__name__)

_TABLES = {}
_COLUMNS = {}
_MODELS = {}
_BROADCASTS = {}
_INJECTABLES = {}

_CACHING = True
_TABLE_CACHE = {}
_COLUMN_CACHE = {}
_INJECTABLE_CACHE = {}


<div class="viewcode-block" id="clear_sim"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.clear_sim">[docs]</a>def clear_sim():
    """
    Clear any stored state from the simulation.

    """
    _TABLES.clear()
    _COLUMNS.clear()
    _MODELS.clear()
    _BROADCASTS.clear()
    _INJECTABLES.clear()
    _TABLE_CACHE.clear()
    _COLUMN_CACHE.clear()
    _INJECTABLE_CACHE.clear()
    logger.debug('simulation state cleared')

</div>
<div class="viewcode-block" id="clear_cache"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.clear_cache">[docs]</a>def clear_cache():
    """
    Clear all cached data.

    """
    _TABLE_CACHE.clear()
    _COLUMN_CACHE.clear()
    _INJECTABLE_CACHE.clear()
    logger.debug('simulation cache cleared')

</div>
<div class="viewcode-block" id="enable_cache"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.enable_cache">[docs]</a>def enable_cache():
    """
    Allow caching of computed tables, columns, and injectables that
    explicitly have caching enabled.

    """
    global _CACHING
    _CACHING = True

</div>
<div class="viewcode-block" id="disable_cache"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.disable_cache">[docs]</a>def disable_cache():
    """
    Turn off caching across the simulation, even for computed tables,
    columns, and injectables that have caching enabled.

    """
    global _CACHING
    _CACHING = False

</div>
<div class="viewcode-block" id="cache_on"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.cache_on">[docs]</a>def cache_on():
    """
    Whether caching is currently enabled or disabled.

    Returns
    -------
    on : bool
        True if caching is enabled.

    """
    return _CACHING


# for errors that occur during simulation runs</div>
class SimulationError(Exception):
    pass


<div class="viewcode-block" id="DataFrameWrapper"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper">[docs]</a>class DataFrameWrapper(object):
    """
    Wraps a DataFrame so it can provide certain columns and handle
    computed columns.

    Parameters
    ----------
    name : str
        Name for the table.
    frame : pandas.DataFrame

    Attributes
    ----------
    name : str
        Table name.

    """
    def __init__(self, name, frame):
        self.name = name
        self._frame = frame

    @property
<div class="viewcode-block" id="DataFrameWrapper.columns"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.columns">[docs]</a>    def columns(self):
        """
        Columns in this table.

        """
        return self.local_columns + _list_columns_for_table(self.name)
</div>
    @property
<div class="viewcode-block" id="DataFrameWrapper.local_columns"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.local_columns">[docs]</a>    def local_columns(self):
        """
        Columns that are part of the wrapped DataFrame.

        """
        return list(self._frame.columns)
</div>
    @property
<div class="viewcode-block" id="DataFrameWrapper.index"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.index">[docs]</a>    def index(self):
        """
        Table index.

        """
        return self._frame.index
</div>
<div class="viewcode-block" id="DataFrameWrapper.to_frame"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.to_frame">[docs]</a>    def to_frame(self, columns=None):
        """
        Make a DataFrame with the given columns.

        Parameters
        ----------
        columns : sequence, optional
            Sequence of the column names desired in the DataFrame.
            If None all columns are returned, including registered columns.

        Returns
        -------
        frame : pandas.DataFrame

        """
        extra_cols = _columns_for_table(self.name)

        if columns:
            local_cols = [c for c in self._frame.columns
                          if c in columns and c not in extra_cols]
            extra_cols = toolz.keyfilter(lambda c: c in columns, extra_cols)
            df = self._frame[local_cols].copy()
        else:
            df = self._frame.copy()

        with log_start_finish(
                'computing {!r} columns for table {!r}'.format(
                    len(extra_cols), self.name),
                logger):
            for name, col in extra_cols.items():
                with log_start_finish(
                        'computing column {!r} for table {!r}'.format(
                            name, self.name),
                        logger):
                    df[name] = col()

        return df
</div>
<div class="viewcode-block" id="DataFrameWrapper.update_col"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.update_col">[docs]</a>    def update_col(self, column_name, series):
        """
        Add or replace a column in the underlying DataFrame.

        Parameters
        ----------
        column_name : str
            Column to add or replace.
        series : pandas.Series or sequence
            Column data.

        """
        logger.debug('updating column {!r} in table {!r}'.format(
            column_name, self.name))
        self._frame[column_name] = series
</div>
    def __setitem__(self, key, value):
        return self.update_col(key, value)

<div class="viewcode-block" id="DataFrameWrapper.get_column"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.get_column">[docs]</a>    def get_column(self, column_name):
        """
        Returns a column as a Series.

        Parameters
        ----------
        column_name : str

        Returns
        -------
        column : pandas.Series

        """
        with log_start_finish(
                'getting single column {!r} from table {!r}'.format(
                    column_name, self.name),
                logger):
            return self.to_frame(columns=[column_name])[column_name]
</div>
    def __getitem__(self, key):
        return self.get_column(key)

    def __getattr__(self, key):
        return self.get_column(key)

<div class="viewcode-block" id="DataFrameWrapper.update_col_from_series"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.update_col_from_series">[docs]</a>    def update_col_from_series(self, column_name, series):
        """
        Update existing values in a column from another series.
        Index values must match in both column and series.

        Parameters
        ---------------
        column_name : str
        series : panas.Series

        """
        logger.debug('updating column {!r} in table {!r}'.format(
            column_name, self.name))
        self._frame[column_name].loc[series.index] = series
</div>
    def __len__(self):
        return len(self._frame)

<div class="viewcode-block" id="DataFrameWrapper.clear_cached"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.DataFrameWrapper.clear_cached">[docs]</a>    def clear_cached(self):
        """
        Remove cached results from this table's computed columns.

        """
        for col in _columns_for_table(self.name).values():
            col.clear_cached()
        logger.debug('cleared cached columns for table {!r}'.format(self.name))

</div></div>
<div class="viewcode-block" id="TableFuncWrapper"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.TableFuncWrapper">[docs]</a>class TableFuncWrapper(object):
    """
    Wrap a function that provides a DataFrame.

    Parameters
    ----------
    name : str
        Name for the table.
    func : callable
        Callable that returns a DataFrame.
    cache : bool, optional
        Whether to cache the results of calling the wrapped function.

    Attributes
    __________
    name : str
        Table name.
    cache : bool
        Whether caching is enabled for this table.

    """
    def __init__(self, name, func, cache=False):
        self.name = name
        self._func = func
        self._arg_list = set(inspect.getargspec(func).args)
        self.cache = cache
        self._columns = []
        self._index = None
        self._len = 0

    @property
<div class="viewcode-block" id="TableFuncWrapper.columns"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.TableFuncWrapper.columns">[docs]</a>    def columns(self):
        """
        Columns in this table. (May contain only computed columns
        if the wrapped function has not been called yet.)

        """
        return self._columns + _list_columns_for_table(self.name)
</div>
    @property
<div class="viewcode-block" id="TableFuncWrapper.local_columns"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.TableFuncWrapper.local_columns">[docs]</a>    def local_columns(self):
        """
        Only the columns contained in the DataFrame returned by the
        wrapped function. (No registered columns included.)

        """
        if self._columns:
            return self._columns
        else:
            self._call_func()
            return self._columns
</div>
    @property
<div class="viewcode-block" id="TableFuncWrapper.index"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.TableFuncWrapper.index">[docs]</a>    def index(self):
        """
        Index of the underlying table. Will be None if that index is
        unknown.

        """
        return self._index
</div>
    def _call_func(self):
        """
        Call the wrapped function and return the result. Also updates
        attributes like columns, index, and length.

        """
        if _CACHING and self.cache and self.name in _TABLE_CACHE:
            logger.debug('returning table {!r} from cache'.format(self.name))
            return _TABLE_CACHE[self.name]

        with log_start_finish(
                'call function to get frame for table {!r}'.format(
                    self.name),
                logger):
            kwargs = _collect_injectables(self._arg_list)
            frame = self._func(**kwargs)

        if self.cache:
            _TABLE_CACHE[self.name] = frame

        self._columns = list(frame.columns)
        self._index = frame.index
        self._len = len(frame)
        return frame

<div class="viewcode-block" id="TableFuncWrapper.to_frame"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.TableFuncWrapper.to_frame">[docs]</a>    def to_frame(self, columns=None):
        """
        Make a DataFrame with the given columns.

        Parameters
        ----------
        columns : sequence, optional
            Sequence of the column names desired in the DataFrame.
            If None all columns are returned.

        Returns
        -------
        frame : pandas.DataFrame

        """
        frame = self._call_func()
        return DataFrameWrapper(self.name, frame).to_frame(columns)
</div>
<div class="viewcode-block" id="TableFuncWrapper.get_column"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.TableFuncWrapper.get_column">[docs]</a>    def get_column(self, column_name):
        """
        Returns a column as a Series.

        Parameters
        ----------
        column_name : str

        Returns
        -------
        column : pandas.Series

        """
        with log_start_finish(
                'getting single column {!r} from table {!r}'.format(
                    column_name, self.name),
                logger):
            return self.to_frame(columns=[column_name])[column_name]
</div>
    def __getitem__(self, key):
        return self.get_column(key)

    def __getattr__(self, key):
        return self.get_column(key)

    def __len__(self):
        return self._len

<div class="viewcode-block" id="TableFuncWrapper.clear_cached"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.TableFuncWrapper.clear_cached">[docs]</a>    def clear_cached(self):
        """
        Remove this table's cached result and that of associated columns.

        """
        _TABLE_CACHE.pop(self.name, None)
        for col in _columns_for_table(self.name).values():
            col.clear_cached()
        logger.debug(
            'cleared cached result and cached columns for table {!r}'.format(
                self.name))

</div></div>
class _TableSourceWrapper(TableFuncWrapper):
    """
    Wraps a function that returns a DataFrame. After the function
    is evaluated the returned DataFrame replaces the function in the
    table registry.

    Parameters
    ----------
    name : str
    func : callable

    Attributes
    ----------
    name : str
        Table name.

    """
    def convert(self):
        """
        Evaluate the wrapped function, store the returned DataFrame as a
        table, and return the new DataFrameWrapper instance created.

        """
        frame = self._call_func()
        return add_table(self.name, frame)

    def to_frame(self, columns=None):
        """
        Make a DataFrame with the given columns. The first time this
        is called the registered table will be replaced with the DataFrame
        returned by the wrapped function.

        Parameters
        ----------
        columns : sequence, optional
            Sequence of the column names desired in the DataFrame.
            If None all columns are returned.

        Returns
        -------
        frame : pandas.DataFrame

        """
        return self.convert().to_frame(columns)


class _ColumnFuncWrapper(object):
    """
    Wrap a function that returns a Series.

    Parameters
    ----------
    table_name : str
        Table with which the column will be associated.
    column_name : str
        Name for the column.
    func : callable
        Should return a Series that has an
        index matching the table to which it is being added.
    cache : bool, optional
        Whether to cache the result of calling the wrapped function.

    Attributes
    ----------
    name : str
        Column name.
    table_name : str
        Name of table this column is associated with.
    cache : bool
        Whether caching is enabled for this column.

    """
    def __init__(self, table_name, column_name, func, cache=False):
        self.table_name = table_name
        self.name = column_name
        self._func = func
        self._arg_list = set(inspect.getargspec(func).args)
        self.cache = cache

    def __call__(self):
        """
        Evaluate the wrapped function and return the result.

        """
        if (_CACHING and
                self.cache and
                (self.table_name, self.name) in _COLUMN_CACHE):
            logger.debug(
                'returning column {!r} for table {!r} from cache'.format(
                    self.name, self.table_name))
            return _COLUMN_CACHE[(self.table_name, self.name)]

        with log_start_finish(
                ('call function to provide column {!r} for table {!r}'
                 ).format(self.name, self.table_name), logger):
            kwargs = _collect_injectables(self._arg_list)
            col = self._func(**kwargs)

        if self.cache:
            _COLUMN_CACHE[(self.table_name, self.name)] = col

        return col

    def clear_cached(self):
        """
        Remove any cached result of this column.

        """
        x = _COLUMN_CACHE.pop((self.table_name, self.name), None)
        if x is not None:
            logger.debug(
                'cleared cached value for column {!r} in table {!r}'.format(
                    self.name, self.table_name))


class _SeriesWrapper(object):
    """
    Wrap a Series for the purpose of giving it the same interface as a
    `_ColumnFuncWrapper`.

    Parameters
    ----------
    table_name : str
        Table with which the column will be associated.
    column_name : str
        Name for the column.
    func : callable
        Should return a Series that has an
        index matching the table to which it is being added.

    Attributes
    ----------
    name : str
        Column name.
    table_name : str
        Name of table this column is associated with.

    """
    def __init__(self, table_name, column_name, series):
        self.table_name = table_name
        self.name = column_name
        self._column = series

    def __call__(self):
        return self._column

    def clear_cached(self):
        """
        Here for compatibility with `_ColumnFuncWrapper`.

        """
        pass


class _InjectableFuncWrapper(object):
    """
    Wraps a function that will be called (with injection) to provide
    an injectable value elsewhere.

    Parameters
    ----------
    name : str
    func : callable
    cache : bool, optional
        Whether to cache the result of calling the wrapped function.

    Attributes
    ----------
    name : str
        Name of this injectable.
    cache : bool
        Whether caching is enabled for this injectable function.

    """
    def __init__(self, name, func, cache=False):
        self.name = name
        self._func = func
        self._arg_list = set(inspect.getargspec(func).args)
        self.cache = cache

    def __call__(self):
        if _CACHING and self.cache and self.name in _INJECTABLE_CACHE:
            logger.debug(
                'returning injectable {!r} from cache'.format(self.name))
            return _INJECTABLE_CACHE[self.name]

        with log_start_finish(
                'call function to provide injectable {!r}'.format(self.name),
                logger):
            kwargs = _collect_injectables(self._arg_list)
            result = self._func(**kwargs)

        if self.cache:
            _INJECTABLE_CACHE[self.name] = result

        return result

    def clear_cached(self):
        """
        Clear a cached result for this injectable.

        """
        x = _INJECTABLE_CACHE.pop(self.name, None)
        if x:
            logger.debug(
                'injectable {!r} removed from cache'.format(self.name))


class _ModelFuncWrapper(object):
    """
    Wrap a model function for dependency injection.

    Parameters
    ----------
    model_name : str
    func : callable

    Attributes
    ----------
    name : str
        Name of model.

    """
    def __init__(self, model_name, func):
        self.name = model_name
        self._func = func
        self._arg_list = set(inspect.getargspec(func).args)

    def __call__(self):
        with log_start_finish('calling model {!r}'.format(self.name), logger):
            kwargs = _collect_injectables(self._arg_list)
            return self._func(**kwargs)

    def _tables_used(self):
        """
        Tables injected into the model.

        Returns
        -------
        tables : list of str

        """
        return [x for x in self._arg_list if _is_table(x)]


def _is_table(name):
    """
    Returns whether a given name refers to a registered table.

    """
    return name in _TABLES


<div class="viewcode-block" id="list_tables"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.list_tables">[docs]</a>def list_tables():
    """
    List of table names.

    """
    return list(_TABLES.keys())

</div>
<div class="viewcode-block" id="list_columns"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.list_columns">[docs]</a>def list_columns():
    """
    List of (table name, registered column name) pairs.

    """
    return list(_COLUMNS.keys())

</div>
<div class="viewcode-block" id="list_models"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.list_models">[docs]</a>def list_models():
    """
    List of registered model names.

    """
    return list(_MODELS.keys())

</div>
<div class="viewcode-block" id="list_injectables"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.list_injectables">[docs]</a>def list_injectables():
    """
    List of registered injectables.

    """
    return list(_INJECTABLES.keys())

</div>
<div class="viewcode-block" id="list_broadcasts"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.list_broadcasts">[docs]</a>def list_broadcasts():
    """
    List of registered broadcasts as (cast table name, onto table name).

    """
    return list(_BROADCASTS.keys())

</div>
def _collect_injectables(names):
    """
    Find all the injectables specified in `names`.

    Parameters
    ----------
    names : list of str

    Returns
    -------
    injectables : dict
        Keys are the names, values are wrappers if the injectable
        is a table. If it's a plain injectable the value itself is given
        or the injectable function is evaluated.

    """
    names = set(names)
    dicts = toolz.keyfilter(
        lambda x: x in names, toolz.merge(_INJECTABLES, _TABLES))

    if set(dicts.keys()) != names:
        raise KeyError(
            'not all injectables found. '
            'missing: {}'.format(names - set(dicts.keys())))

    for name, thing in dicts.items():
        if isinstance(thing, _InjectableFuncWrapper):
            dicts[name] = thing()
        elif isinstance(thing, _TableSourceWrapper):
            dicts[name] = thing.convert()

    return dicts


<div class="viewcode-block" id="add_table"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.add_table">[docs]</a>def add_table(table_name, table, cache=False):
    """
    Register a table with the simulation.

    Parameters
    ----------
    table_name : str
        Should be globally unique to this table.
    table : pandas.DataFrame or function
        If a function it should return a DataFrame. Function argument
        names will be matched to known tables, which will be injected
        when this function is called.
    cache : bool, optional
        Whether to cache the results of a provided callable. Does not
        apply if `table` is a DataFrame.

    Returns
    -------
    wrapped : `DataFrameWrapper` or `TableFuncWrapper`

    """
    if isinstance(table, pd.DataFrame):
        table = DataFrameWrapper(table_name, table)
    elif isinstance(table, Callable):
        table = TableFuncWrapper(table_name, table, cache)
    else:
        raise TypeError('table must be DataFrame or function.')

    # clear any cached data from a previously registered table
    table.clear_cached()

    logger.debug('registering table {!r}'.format(table_name))
    _TABLES[table_name] = table

    return table

</div>
<div class="viewcode-block" id="table"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.table">[docs]</a>def table(table_name, cache=False):
    """
    Decorator version of `add_table` used for decorating functions
    that return DataFrames.

    Decorated function argument names will be matched to known tables,
    which will be injected when this function is called.

    """
    def decorator(func):
        add_table(table_name, func, cache=cache)
        return func
    return decorator

</div>
<div class="viewcode-block" id="add_table_source"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.add_table_source">[docs]</a>def add_table_source(table_name, func):
    """
    Add a DataFrame source function to the simulation. This function is
    evaluated only once, after which the returned DataFrame replaces
    `func` as the injected table.

    Parameters
    ----------
    table_name : str
    func : callable
        Function argument names will be matched to known injectables,
        which will be injected when this function is called.

    Returns
    -------
    wrapped : `_TableSourceWrapper`

    """
    wrapped = _TableSourceWrapper(table_name, func)
    logger.debug('registering table source {}'.format(table_name))
    _TABLES[table_name] = wrapped
    return wrapped

</div>
<div class="viewcode-block" id="table_source"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.table_source">[docs]</a>def table_source(table_name):
    """
    Decorator version of `add_table_source`. Use it to decorate a function
    that returns a DataFrame. The function will be evaluated only once
    and the DataFrame will replace it.

    """
    def decorator(func):
        add_table_source(table_name, func)
        return func
    return decorator

</div>
<div class="viewcode-block" id="get_table"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.get_table">[docs]</a>def get_table(table_name):
    """
    Get a registered table.

    Table sources will be converted to `DataFrameWrapper`.

    Parameters
    ----------
    table_name : str

    Returns
    -------
    table : `DataFrameWrapper` or `TableFuncWrapper`

    """
    if table_name in _TABLES:
        table = _TABLES[table_name]
        if isinstance(table, _TableSourceWrapper):
            table = table.convert()
        return table
    else:
        raise KeyError('table not found: {}'.format(table_name))

</div>
<div class="viewcode-block" id="add_column"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.add_column">[docs]</a>def add_column(table_name, column_name, column, cache=False):
    """
    Add a new column to a table from a Series or callable.

    Parameters
    ----------
    table_name : str
        Table with which the column will be associated.
    column_name : str
        Name for the column.
    column : pandas.Series or callable
        If a callable it should return a Series. Any Series should have an
        index matching the table to which it is being added.
    cache : bool, optional
        Whether to cache the results of a provided callable. Does not
        apply if `column` is a Series.

    """
    if isinstance(column, pd.Series):
        column = _SeriesWrapper(table_name, column_name, column)
    elif isinstance(column, Callable):
        column = \
            _ColumnFuncWrapper(table_name, column_name, column, cache=cache)
    else:
        raise TypeError('Only Series or callable allowed for column.')

    # clear any cached data from a previously registered column
    column.clear_cached()

    logger.debug('registering column {!r} on table {!r}'.format(
        column_name, table_name))
    _COLUMNS[(table_name, column_name)] = column

    return column

</div>
<div class="viewcode-block" id="column"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.column">[docs]</a>def column(table_name, column_name, cache=False):
    """
    Decorator version of `add_column` used for decorating functions
    that return a Series with an index matching the named table.

    The argument names of the function should match known tables, which
    will be injected.

    """
    def decorator(func):
        add_column(table_name, column_name, func, cache=cache)
        return func
    return decorator

</div>
def _list_columns_for_table(table_name):
    """
    Return a list of all the extra columns registered for a given table.

    Parameters
    ----------
    table_name : str

    Returns
    -------
    columns : list of str

    """
    return [cname for tname, cname in _COLUMNS.keys() if tname == table_name]


def _columns_for_table(table_name):
    """
    Return all of the columns registered for a given table.

    Parameters
    ----------
    table_name : str

    Returns
    -------
    columns : dict of column wrappers
        Keys will be column names.

    """
    return {cname: col
            for (tname, cname), col in _COLUMNS.items()
            if tname == table_name}


<div class="viewcode-block" id="add_injectable"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.add_injectable">[docs]</a>def add_injectable(name, value, autocall=True, cache=False):
    """
    Add a value that will be injected into other functions that
    are part of the simulation.

    Parameters
    ----------
    name : str
    value
        If a callable and `autocall` is True then the function will be
        evaluated using dependency injection and the return value will
        be passed to any functions using this injectable. In all other
        cases `value` will be passed through untouched.
    autocall : bool, optional
        Set to True to have injectable functions automatically called
        (with dependency injection) and the result injected instead of
        the function itself.
    cache : bool, optional
        Whether to cache the return value of an injectable function.
        Only applies when `value` is a callable and `autocall` is True.

    """
    if isinstance(value, Callable) and autocall:
        value = _InjectableFuncWrapper(name, value, cache=cache)
        # clear any cached data from a previously registered value
        value.clear_cached()
    logger.debug('registering injectable {!r}'.format(name))
    _INJECTABLES[name] = value

</div>
<div class="viewcode-block" id="injectable"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.injectable">[docs]</a>def injectable(name, autocall=True, cache=False):
    """
    Decorator version of `add_injectable`.

    """
    def decorator(func):
        add_injectable(name, func, autocall=autocall, cache=cache)
        return func
    return decorator

</div>
<div class="viewcode-block" id="get_injectable"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.get_injectable">[docs]</a>def get_injectable(name):
    """
    Get an injectable by name. *Does not* evaluate wrapped functions.

    Parameters
    ----------
    name : str

    Returns
    -------
    injectable
        Original value or _InjectableFuncWrapper if autocall was True.

    """
    if name in _INJECTABLES:
        return _INJECTABLES[name]
    else:
        raise KeyError('injectable not found: {}'.format(name))

</div>
<div class="viewcode-block" id="add_model"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.add_model">[docs]</a>def add_model(model_name, func):
    """
    Add a model function to the simulation.

    Model argument names are used for injecting known tables of the same name.
    The argument name "year" may be used to have the current simulation
    year injected.

    Parameters
    ----------
    model_name : str
    func : callable

    """
    if isinstance(func, Callable):
        logger.debug('registering model {!r}'.format(model_name))
        _MODELS[model_name] = _ModelFuncWrapper(model_name, func)
    else:
        raise TypeError('func must be a callable')

</div>
<div class="viewcode-block" id="model"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.model">[docs]</a>def model(model_name):
    """
    Decorator version of `add_model`, used to decorate a function that
    will require injection of tables and that can be run by the
    `run` function.

    """
    def decorator(func):
        add_model(model_name, func)
        return func
    return decorator

</div>
<div class="viewcode-block" id="get_model"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.get_model">[docs]</a>def get_model(model_name):
    """
    Get a wrapped model by name.

    Parameters
    ----------

    """
    if model_name in _MODELS:
        return _MODELS[model_name]
    else:
        raise KeyError('no model named {}'.format(model_name))

</div>
_Broadcast = namedtuple(
    '_Broadcast',
    ['cast', 'onto', 'cast_on', 'onto_on', 'cast_index', 'onto_index'])


<div class="viewcode-block" id="broadcast"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.broadcast">[docs]</a>def broadcast(cast, onto, cast_on=None, onto_on=None,
              cast_index=False, onto_index=False):
    """
    Register a rule for merging two tables by broadcasting one onto
    the other.

    Parameters
    ----------
    cast, onto : str
        Names of registered tables.
    cast_on, onto_on : str, optional
        Column names used for merge, equivalent of ``left_on``/``right_on``
        parameters of pandas.merge.
    cast_index, onto_index : bool, optional
        Whether to use table indexes for merge. Equivalent of
        ``left_index``/``right_index`` parameters of pandas.merge.

    """
    logger.debug(
        'registering broadcast of table {!r} onto {!r}'.format(cast, onto))
    _BROADCASTS[(cast, onto)] = \
        _Broadcast(cast, onto, cast_on, onto_on, cast_index, onto_index)

</div>
def _get_broadcasts(tables):
    """
    Get the broadcasts associated with a set of tables.

    Parameters
    ----------
    tables : sequence of str
        Table names for which broadcasts have been registered.

    Returns
    -------
    casts : dict of `_Broadcast`
        Keys are tuples of strings like (cast_name, onto_name).

    """
    tables = set(tables)
    casts = toolz.keyfilter(
        lambda x: x[0] in tables and x[1] in tables, _BROADCASTS)
    if tables - set(toolz.concat(casts.keys())):
        raise ValueError('Not enough links to merge all tables.')
    return casts


# utilities for merge_tables
def _all_reachable_tables(t):
    """
    A generator that provides all the names of tables that can be
    reached via merges starting at the given target table.

    """
    for k, v in t.items():
        for tname in _all_reachable_tables(v):
            yield tname
        yield k


def _recursive_getitem(d, key):
    """
    Descend into a dict of dicts to return the one that contains
    a given key. Every value in the dict must be another dict.

    """
    if key in d:
        return d
    else:
        for v in d.values():
            return _recursive_getitem(v, key)
        else:
            raise KeyError('Key not found: {}'.format(key))


def _dict_value_to_pairs(d):
    """
    Takes the first value of a dictionary (which it self should be
    a dictionary) and turns it into a series of {key: value} dicts.

    For example, _dict_value_to_pairs({'c': {'a': 1, 'b': 2}}) will yield
    {'a': 1} and {'b': 2}.

    """
    d = d[toolz.first(d)]

    for k, v in d.items():
        yield {k: v}


def _is_leaf_node(merge_node):
    """
    Returns True for dicts like {'a': {}}.

    """
    return len(merge_node) == 1 and not merge_node.values()[0]


def _next_merge(merge_node):
    """
    Gets a node that has only leaf nodes below it. This table and
    the ones below are ready to be merged to make a new leaf node.

    """
    if all(_is_leaf_node(d) for d in _dict_value_to_pairs(merge_node)):
        return merge_node
    else:
        for d in toolz.remove(_is_leaf_node, _dict_value_to_pairs(merge_node)):
            return _next_merge(d)
        else:
            raise SimulationError('No node found for next merge.')


<div class="viewcode-block" id="merge_tables"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.merge_tables">[docs]</a>def merge_tables(target, tables, columns=None):
    """
    Merge a number of tables onto a target table. Tables must have
    registered merge rules via the `broadcast` function.

    Parameters
    ----------
    target : str, DataFrameWrapper, or TableFuncWrapper
        Name of the table (or wrapped table) onto which tables will be merged.
    tables : list of `DataFrameWrapper`, `TableFuncWrapper`, or str
        All of the tables to merge. Should include the target table.
    columns : list of str, optional
        If given, columns will be mapped to `tables` and only those columns
        will be requested from each table. The final merged table will have
        only these columns. By default all columns are used from every
        table.

    Returns
    -------
    merged : pandas.DataFrame

    """
    # allow target to be string or table wrapper
    if isinstance(target, (DataFrameWrapper, TableFuncWrapper)):
        target = target.name

    # allow tables to be strings or table wrappers
    tables = [get_table(t)
              if not isinstance(t, (DataFrameWrapper, TableFuncWrapper)) else t
              for t in tables]

    merges = {t.name: {} for t in tables}
    tables = {t.name: t for t in tables}
    casts = _get_broadcasts(tables.keys())
    logger.debug(
        'attempting to merge tables {} to target table {}'.format(
            tables.keys(), target))

    # relate all the tables by registered broadcasts
    for table, onto in casts:
        merges[onto][table] = merges[table]
    merges = {target: merges[target]}

    # verify that all the tables can be merged to the target
    all_tables = set(_all_reachable_tables(merges))

    if all_tables != set(tables.keys()):
        raise RuntimeError(
            ('Not all tables can be merged to target "{}". Unlinked tables: {}'
             ).format(target, list(set(tables.keys()) - all_tables)))

    # add any columns necessary for indexing into other tables
    # during merges
    if columns:
        columns = list(columns)
        for c in casts.values():
            if c.onto_on:
                columns.append(c.onto_on)
            if c.cast_on:
                columns.append(c.cast_on)

    # get column map for which columns go with which table
    colmap = column_map(tables.values(), columns)

    # get frames
    frames = {name: t.to_frame(columns=colmap[name])
              for name, t in tables.items()}

    # perform merges until there's only one table left
    while merges[target]:
        nm = _next_merge(merges)
        onto = toolz.first(nm)
        onto_table = frames[onto]

        # loop over all the tables that can be broadcast onto
        # the onto_table and merge them all in.
        for cast in nm[onto]:
            cast_table = frames[cast]
            bc = casts[(cast, onto)]

            with log_start_finish(
                    'merge tables {} and {}'.format(onto, cast), logger):

                onto_table = pd.merge(
                    onto_table, cast_table,
                    left_on=bc.onto_on, right_on=bc.cast_on,
                    left_index=bc.onto_index, right_index=bc.cast_index)

        # replace the existing table with the merged one
        frames[onto] = onto_table

        # free up space by dropping the cast table
        del frames[cast]

        # mark the onto table as having no more things to broadcast
        # onto it.
        _recursive_getitem(merges, onto)[onto] = {}

    logger.debug('finished merge')
    return frames[target]

</div>
<div class="viewcode-block" id="write_tables"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.write_tables">[docs]</a>def write_tables(fname, models, year):
    """
    Write all tables injected into `models` to a pandas.HDFStore file.
    If year is not None it will be used to prefix the table names so that
    multiple years can go in the same file.

    Parameters
    ----------
    fname : str
        File name for HDFStore. Will be opened in append mode and closed
        at the end of this function.
    models : list of str
        Models from which to gather injected tables for saving.
    year : int or None
        If an integer, used as a prefix along with table names for
        labeling DataFrames in the HDFStore.

    """
    models = (get_model(m) for m in toolz.unique(models))
    table_names = toolz.unique(toolz.concat(m._tables_used() for m in models))
    tables = (get_table(t) for t in table_names)

    key_template = '{}/{{}}'.format(year) if year is not None else '{}'

    with pd.get_store(fname, mode='a') as store:
        for t in tables:
            store[key_template.format(t.name)] = t.to_frame()

</div>
<div class="viewcode-block" id="run"><a class="viewcode-back" href="../../../sim/index.html#urbansim.sim.simulation.run">[docs]</a>def run(models, years=None, data_out=None, out_interval=1):
    """
    Run models in series, optionally repeatedly over some years.
    The current year is set as a global injectable.

    Parameters
    ----------
    models : list of str
        List of models to run identified by their name.
    years : sequence of int, optional
        Years over which to run the models. `year` is provided as
        an injectable throughout the simulation. If not given the models
        are run once with year set to None.
    data_out : str, optional
        An optional filename to which all tables injected into any model
        in `models` will be saved every `out_interval` years.
        File will be a pandas HDF data store.
    out_interval : int, optional
        Year interval on which to save data to `data_out`. For example,
        2 will save out every 2 years, 5 every 5 years. Default is every
        year. The first and last years are always included.

    """
    years = years or [None]
    year_counter = out_interval

    for year in years:
        add_injectable('year', year)

        if data_out and year_counter == out_interval:
            write_tables(data_out, models, year)
            year_counter = 0

        if year is not None:
            print('Running year {}'.format(year))
            logger.debug('running year {}'.format(year))

        t1 = time.time()
        for model_name in models:
            print('Running model {!r}'.format(model_name))
            with log_start_finish(
                    'run model {!r}'.format(model_name), logger, logging.INFO):
                model = get_model(model_name)
                t2 = time.time()
                model()
                print("Time to execute model '{}': {:.2f}s".format(
                      model_name, time.time()-t2))

        print("Total time to execute{}: {:.2f}s".format(
            " year %d" % year if year is not None else '', time.time()-t1))
        year_counter += 1

    if data_out:
        write_tables(data_out, models, 'final')</div>
</pre>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Synthicity.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.2dev',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>